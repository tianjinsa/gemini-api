# Vue 3 层叠卡片布局组件库 - 技术规格书# 技术规格书

## 1. 概述## **技术规格书：`vue-layered-layout` 通用布局组件库**

本组件库为 Vue 3 应用提供一套灵活的层叠卡片布局系统,支持桌面端(水平布局)和移动端(垂直布局)的自动切换。### **1. 核心设计哲学与愿景 (Core Philosophy & Vision)**

### 1.1 核心特性`vue-layered-layout` 的核心定位是一个**纯粹的、非侵入式的布局与交互基元 (Layout and Interaction Primitive)**，而非一个功能性的 UI 组件库。其设计哲学与 HTML 的 `<table>` 元素高度相似：它只负责定义结构、空间划分和高级交互行为，而对内部承载的**具体内容和功能完全保持不可知（agnostic）**

- **多卡片组支持**: 支持在同一容器中创建多个独立的卡片组,每个组可以有独立的样式和配置**本库的职责范围：**

- **自适应布局**: 根据容器宽度自动切换水平/垂直布局

- **尺寸解析约束**: 水平宽度字段仅接受像素, 垂直高度字段支持像素与 `vh`

- **TypeScript 支持**: 完整的类型定义    1. **空间划分：** 提供一个容器，用于管理一组可动态增减的“卡片”单元。

- **非侵入式**: 作为布局原语,不强制特定的 UI 风格    2. **布局计算：** 实现复杂的响应式布局算法，包括桌面端的多行智能打包和移动端的垂直堆叠。

    3. **状态管理：** 管理每个卡片的两种核心状态——“聚焦”与“非聚焦”。

## 2. 架构设计    4. **交互基元提供：** 提供一个通用的“悬停展开式容器”(`HoverExpandContainer`)，用于实现视觉无缝的展开/收起动画，但不预设其内部功能

### 2.1 组件层次结构* **“不做什么” (What we DON'T DO):**

    1. **不预设功能：** 不包含任何预制的“过滤”、“排序”或“刷新”按钮。所有功能性元素均由使用者通过插槽自定义。

```    2. **不预设内容：** 不提供默认的标题、文本或任何UI元素。卡片的头部和主体区域是完全由使用者填充的容器。

LayeredLayoutContainer (容器组件)    3. **不干涉样式：** 除了布局所需的结构性样式（如 `position`, `transform`, `width` 等），本库不应包含任何装饰性样式（如颜色、字体、边框样式等），以确保能无缝融入任何项目的设计系统。

  └── LayeredLayoutGroup (卡片组组件) - 可以有多个

        └── LayeredLayoutCard (卡片组件) - 每个组内可以有多个卡片最终目标是交付一个强大、可预测且高度可定制的布局“引擎”，让开发者可以专注于业务逻辑和UI实现，而无需处理复杂的响应式层叠布局计算。

```

---

### 2.2 核心组件

### **2. 系统架构与组件 API (System Architecture & Component API)**

#### 2.2.1 LayeredLayoutContainer

系统由三个核心组件构成，它们通过 `props` 和 `slots` 协同工作，遵循严格的单向数据流和关注点分离原则。

**作用**: 顶层容器,用于包裹多个卡片组。

#### **2.1. `LayeredLayoutContainer.vue`**

**Props**:
这是布局系统的根容器，是所有布局逻辑的计算和分发中心。

```typescript

interface LayeredLayoutContainerProps {

  groups: CardGroupConfig[]; // 卡片组配置数组* **Props:**

}

```    ```typescript

    interface Props {

**特点**:      /**

- 简单的包裹容器       * 定义所有卡片的基础配置信息。

- 不处理布局逻辑       * 这是驱动整个布局的核心数据源。

- 通过 slot 渲染子卡片组       */

      cards: CardConfig[];

#### 2.2.2 LayeredLayoutGroup    }

    ```

**作用**: 单个卡片组,管理一组卡片的布局。

* **Slots:**

**Props**:  * `default`: 默认插槽，用于放置 `LayeredLayoutCard` 组件。它会向子组件作用域内暴露 `card` (当前卡片配置) 和 `layout` (计算出的布局信息) 两个变量。

```typescript

interface CardGroupConfig {    ```html

  id: string;                    // 组 ID    <template #default="{ card, layout }">

  cards: CardConfig[];           // 卡片配置      <LayeredLayoutCard

  className?: string;            // 自定义 CSS 类名        :key="card.id"

  style?: Record<string, string | number>; // 内联样式        :is-focused="layout.isFocused"

  breakpoint?: number;           // 断点宽度 (默认: 960px)        :style="layout.style"

  activeBuffer?: number;         // 激活缓冲区 (默认: 20px)      >

}        <!-- Card content goes here -->

```      </LayeredLayoutCard>

    </template>

**特点**:    ```

- 独立管理卡片组的布局状态

- 支持自定义样式和类名#### **2.2. `LayeredLayoutCard.vue`**

- 可以设置独立的 breakpoint

- 使用 ResizeObserver 监听容器尺寸变化代表一个独立的、可聚焦的卡片单元。它是一个纯粹的内容容器。



#### 2.2.3 LayeredLayoutCard* **Props:**



**作用**: 单个卡片组件。    ```typescript

    interface Props {

**Slots**:      /**

- `header`: 卡片头部内容       * 由父组件计算并传入，决定当前卡片是否处于聚焦状态。

- `body`: 卡片主体内容       * 这是卡片唯一的两种状态之一。

       */

**特点**:      isFocused: boolean;

- 使用 ResizeObserver 自动测量尺寸    }

- 支持聚焦/失焦状态    ```

- 支持点击切换焦点

* **Slots:**

## 3. 布局算法  * `header`: 用于定义卡片头部区域的内容。此区域在卡片未聚焦时可见。

  * `body`: 用于定义卡片主体区域的内容。此区域仅在卡片聚焦时完全可见。

### 3.1 方向判断

#### **2.3. `HoverExpandContainer.vue`**

不再使用固定的 breakpoint 来判断方向,而是基于**容器实际宽度**:

一个独立的、可复用的交互基元，用于实现“克隆-展开”效果的通用容器。

```typescript

// 计算所有卡片需要的最小总宽度* **Slots:**

const totalMinWidth = cards.reduce((sum, card) => {  * `trigger`: 用于定义折叠状态下可见的触发器内容。通常是一个图标或按钮。

  return sum + card.headerWidth + card.minContentWidth;  * `content`: 用于定义展开状态下显示的内容。可以是输入框、下拉列表或任何自定义组件。

}, 0);

---

// 如果容器无法容纳,切换到垂直布局

const orientation = totalMinWidth > containerWidth ? 'vertical' : 'horizontal';### **3. 数据模型 (Data Model)**

```

这是使用者与本库交互的**唯一数据契约**。

### 3.2 尺寸计算

```typescript

#### 3.2.1 水平布局 (桌面端)/**

 * @description 定义单个卡片的核心布局配置。

``` * 这是驱动 `LayeredLayoutContainer` 布局算法的唯一输入。

┌────┬─────────────────────┐ */

│    │                     │export interface CardConfig {

│ H1 │   Content 1         │  /**

│    │                     │   * 卡片的全局唯一标识符，用于 Vue 的 `key` 绑定和内部状态管理。

└────┼─────────────────────┘   * @example 'ip-list-card'

     ├──────────┬───────────────────┐   */

     │          │                   │  id: string;

     │    H2    │    Content 2      │

     │          │                   │  /**

     └──────────┴───────────────────┘   * [桌面端] 卡片内容区域的最小期望宽度。

```   * 仅支持像素值，既可以是数值（默认视为 px），也可以是 `'600px'` 形式。

   * 这是多行打包算法进行换行决策的核心依据。

- 每个卡片占用宽度 = `headerWidth + mainSize`   */

- 未聚焦时显示宽度 = `headerWidth` (折叠状态)  minContentWidth?: number | `${number}px`;

- 聚焦时显示宽度 = `headerWidth + mainSize + activeBuffer`

  /**

#### 3.2.2 垂直布局 (移动端)   * [移动端可选] 卡片内容区域的目标高度。

   * 支持像素和视口高度单位，用于垂直堆叠模式。

```   */

┌──────────────────────────┐  contentHeight?: number | `${number}px` | `${number}vh`;

│         Header 1         │

├──────────────────────────┤  /**

│                          │   * [可选] 内容区上限，采用与 `minContentWidth` 相同的像素规则。

│        Content 1         │   */

│                          │  maxContentWidth?: number | `${number}px`;

└──────────────────────────┘

┌──────────────────────────┐

│         Header 2         │  /**

├──────────────────────────┤   * [可选] 定义该卡片是否应在初始加载时被聚焦。

```   */

  initialFocus?: boolean;

  /**

   * [可选] 自定义栈叠顺序。

   */

  zIndex?: number;
}

### 3.3 CSS 单位解析

```typescript
function resolvePxLength(value: number | string | null | undefined, fallback: number): number {
  if (value == null) return fallback;
  if (typeof value === 'number') return value >= 0 ? value : fallback;

  const normalized = String(value).trim().toLowerCase();
  if (!normalized) return fallback;

  if (/^-?\d+(\.\d+)?$/.test(normalized)) {
    return Math.max(0, Number.parseFloat(normalized));
  }

  if (normalized.endsWith('px')) {
    return Math.max(0, Number.parseFloat(normalized.slice(0, -2)));
  }

  return fallback;
}

function resolveContentHeightSize(
  value: number | string | null | undefined,
  viewportHeight: number,
  fallback: number
): number {
  if (value == null) return fallback;
  if (typeof value === 'number') return value >= 0 ? value : fallback;

  const normalized = String(value).trim().toLowerCase();
  if (!normalized) return fallback;

  if (/^-?\d+(\.\d+)?$/.test(normalized)) {
    return Math.max(0, Number.parseFloat(normalized));
  }

  if (normalized.endsWith('px')) {
    return Math.max(0, Number.parseFloat(normalized.slice(0, -2)));
  }

  if (normalized.endsWith('vh')) {
    const ratio = Number.parseFloat(normalized.slice(0, -2));
    if (!Number.isFinite(ratio) || viewportHeight <= 0) return fallback;
    return Math.max(0, (ratio / 100) * viewportHeight);
  }

  return fallback;
}
```

> 宽度字段拒绝 `%` 或 `vw`，以确保在复杂嵌套容器中仍然可预测；`vh` 会在视口高度变化时通过 `setViewport` 重新计算。

## 4. 数据结构布局算法依赖于精确的卡片头部尺寸。为此，组件间需要一套可靠的通信协议

### 4.1 CardConfig1. **`LayeredLayoutContainer` (父):**

    * 创建一个响应式 `Map` 对象 `headerSizes` 用于存储所有子卡片的头部尺寸：`const headerSizes = reactive(new Map<string, { width: number; height: number }>())`。

```typescript    * 通过 Vue 的 `provide` API，向所有后代组件提供一个回调函数 `reportHeaderSize`。

interface CardConfig {

  id: string;    ```typescript

  minContentWidth?: CSSSize;     // 默认: 500    provide('reportHeaderSize', (id: string, size: { width: number; height: number }) => {

  minContentHeight?: CSSSize;    // 默认: 500      headerSizes.set(id, size);

  maxContentWidth?: CSSSize;     // 可选    });

  maxContentHeight?: CSSSize;    // 可选    ```

  headerWidth?: number;          // 自定义头部宽度(px)

  headerHeight?: number;         // 自定义头部高度(px)2. **`LayeredLayoutCard` (子):**

  initialFocus?: boolean;        // 是否初始聚焦    * 通过 `inject` API 获取 `reportHeaderSize` 函数。

  zIndex?: number;               // 层级    * 在其 `header` 插槽的根元素上挂载一个 `ResizeObserver`。

}    * 当头部尺寸发生变化时，调用 `reportHeaderSize` 函数，将自身的 `id` 和新的尺寸上报给父容器。

```

#### **4.2. 响应式布局引擎**

### 4.2 CardGroupConfig

- **触发：** 在 `LayeredLayoutContainer` 的根元素上挂载 `ResizeObserver`，实时监听容器尺寸变化。

```typescript* **模式切换：** 根据预设的断点（例如 `960px`）和容器宽度，计算出一个响应式的 `layoutMode` 状态 (`'desktop'` 或 `'mobile'`)。

interface CardGroupConfig {* **状态重置：** 当 `layoutMode` 发生切换时，必须清空 `headerSizes` Map，强制所有子卡片重新测量并上报其在新模式下的尺寸，防止尺寸污染。

  id: string;

  cards: CardConfig[];#### **4.3. 单行层叠布局算法 (Layered Stack Algorithm)**

  className?: string;

  style?: Record<string, string | number>;核心布局逻辑由 `useLayeredLayout` Composable 提供。算法以**单行层叠**为基础，通过上层卡片在主轴方向前移遮挡下层卡片的主体区域来制造层叠感，头部区域始终保持可见，从视觉上看似“折叠”。

  breakpoint?: number;           // 默认: 960

  activeBuffer?: number;         // 默认: 20* **输入：**

}  * 容器尺寸（由 `ResizeObserver` 提供）。

```  * `CardConfig` 数组，包括所有主轴/交叉轴的尺寸约束与可选固定值。

- 卡片头部的实时尺寸（通过 `updateCardHeader` 上报）。

## 5. 状态管理

- **主轴尺寸决策：**

每个 `LayeredLayoutGroup` 维护独立的内部状态:  1. 针对当前断点（桌面 `horizontal` / 移动 `vertical`）解析所有 CSS 长度：

     * 数字默认视为 px。

```typescript     * `vw/vh/%` 会被转换为对应的视口或容器像素值。

interface InternalCardState {  2. 计算每张卡片在被遮挡状态下仍需保留在视口中的主轴占位：`collapsedSpan_i = max(headerSize_i, baseMin_i)`，它对应的是卡片在被上层面板遮住主体时仍能露出的头部宽度。

  id: string;  3. 确定当前聚焦卡片（显式焦点优先，缺省时回退到最后一个卡片）。

  zIndex: number;  4. 对聚焦卡片计算展开宽度/高度：`expandedSpan = min(max(fixed, measured, min, fallback), containerMain)`，其中 `fallback = containerMain - Σ(collapsedSpan_j)`（排除自身），并确保不小于 `minExpandedWidth`（桌面）或 `minVerticalHeight`（移动）。

  headerWidth: number;          // 实际测量或用户指定  5. 对最后一个卡片强制校正：`mainSpan_last = max(expandedSpan_last, containerMain - offset_last)`，保证最后一个卡片的主轴尺寸总是精确对齐容器边界，不产生残余空白。

  headerHeight: number;         // 实际测量或用户指定

  contentWidth: number;         // ResizeObserver 测量* **交叉轴尺寸：**

  contentHeight: number;        // ResizeObserver 测量  * 支持 `fixed/min/max` CSS 长度解析；

  isFocused: boolean;  * 在桌面模式下至少保持 `minVerticalHeight`，避免移动端高度塌陷。

  config: CardConfig;

}#### **4.4. 布局结果计算**

```

对每一个卡片生成如下派生状态：

## 6. CSS 变量

1. **偏移量 (offset)：** 来自之前所有卡片的 `activeMin` 之和。

组件暴露以下 CSS 变量供样式定制:2. **激活占位 (activeMin)：** 用于控制下一张卡片的堆叠位置与缓冲间隙。聚焦卡片使用 `activeMin_i = mainSpan_i + activeBuffer`，其他卡片使用 `activeMin_i = collapsedSpan_i`，表示仅在头部区域可见、主体被遮挡。

```css3. **样式生成：** 输出 `style` 对象，包含：

--vl-total-span       /*布局总跨度*/   * 主轴尺寸（`width` 或 `height`）——优先使用解析后的 CSS 长度；

--panel-header-size   /*头部尺寸*/   * 偏移定位（`left/top`）；

--panel-main-size     /*主体尺寸*/   * 标准化的 CSS 自定义属性：`--panel-main-size`、`--panel-collapsed-main`、`--panel-active-min`、`--panel-cross-size`。

--panel-collapsed-main /*折叠时尺寸*/4. **总跨度 (`totalSpan`)：** `max(offset + mainSpan)`，用于容器尺寸的滚动或动画基准。

--panel-active-min    /*激活时最小尺寸*/

```#### **4.5. 焦点管理 (`initialFocus` 与交互切换)**

## 7. 事件与交互* 初始聚焦优先取 `cards.find(c => c.initialFocus)`，否则回退到数组最后一个卡片，确保桌面端主内容区始终展开

- `setFocusedCard(id)` 接收用户交互并立即更新内部 `isFocused` 标记；传入 `null` 时，同样回退到最后一个卡片。

### 7.1 焦点管理* 布局计算始终引用当前 `isFocused` 状态生成 `activeCardId`，供 UI 同步渲染

- 点击卡片头部切换焦点#### **4.6. `HoverExpandContainer` 的“克隆-传送-变形”机制**

- 同一组内只有一个卡片可以聚焦

- 不同组之间的焦点互不影响这是实现无布局抖动动画的核心。

### 7.2 尺寸监听1. **状态：** 组件内部维护 `isExpanded` 状态

2. **触发 (`mouseenter` on `#trigger` slot):**

- 使用 ResizeObserver 监听:    a. 获取 `#trigger` 根元素的 `getBoundingClientRect()`。

  - 卡片组容器尺寸    b. **显示传送门：** 激活一个 `Teleport` 到 `body` 的内部 `div` (`.clone`)。

  - 每个卡片的头部尺寸    c. **克隆与定位：** 将 `.clone` 的样式（`width`, `height`, `top`, `left`）设置为与 `getBoundingClientRect()` 完全匹配，并将其内容填充为 `#trigger` 插槽的内容。

  - 每个卡片的内容尺寸    d. **隐藏本体：** 将 `#trigger` 插槽的根元素设置为 `visibility: hidden`。

- 尺寸变化自动触发布局重算    e. **展开：** 在 `nextTick` 中，将 `isExpanded` 设为 `true`。`.clone` 元素监听此状态变化，通过 CSS `transition` 平滑地改变其 `width` 和内部内容的 `opacity`，并切换其内容为 `#content` 插槽。

3. **收起 (`mouseleave` from `.clone`):**

## 8. 默认值    a. 将 `isExpanded` 设为 `false`，触发逆向 CSS `transition`

    b. 监听 `transitionend` 事件。动画结束后，隐藏 `.clone`，并将 `#trigger` 根元素的 `visibility` 恢复为 `visible`。

```typescript

const DEFAULTS = {---

  minContentSize: 500,          // 最小内容尺寸

  breakpoint: 960,              // 断点宽度### **5. 构建与分发策略 (Build & Distribution Strategy)**（跳过分发）

  activeBuffer: 20,             // 激活缓冲

  minHeaderHorizontal: 72,      // 最小头部宽度* **构建工具：** Vite，启用**库模式 (Library Mode)**。

  minHeaderVertical: 56,        // 最小头部高度* **入口文件 (`src/index.ts`):** 导出所有公共组件 (`LayeredLayoutContainer`, `LayeredLayoutCard`, `HoverExpandContainer`) 和类型 (`CardConfig`)。

  maxHeaderHorizontal: 960,     // 最大头部宽度* **`package.json`:**

  maxHeaderVertical: 640        // 最大头部高度  * **`"main"`, `"module"`, `"exports"`:** 正确指向 `dist/` 目录下的 CJS 和 ESM 构建产物。

};  * **`"types"`:** 指向 `dist/index.d.ts`。

```  * **`"files"`:** `["dist"]`。

  * **`"peerDependencies"`:** `{"vue": "^3.2.0"}`，明确告知使用者本库需要宿主项目提供 Vue。

## 9. 使用示例* **类型定义：** 使用 `vite-plugin-dts` 插件在构建时自动生成 `.d.ts` 文件，提供完整的 TypeScript 支持。

* **样式：** 所有组件样式使用 `<style scoped>` 封装。Vite 会将所有 CSS 提取到一个单独的 `style.css` 文件中，使用者需要手动引入。

### 9.1 单卡片组

---

```vue

<template>此文档详尽地阐述了 `vue-layered-layout` 组件库的设计理念、架构、核心算法和交付标准，旨在为工程实现提供一份清晰、完整、无歧义的指导蓝图。

  <LayeredLayoutContainer :groups="groups">
    <template #default="{ group }">
      <LayeredLayoutGroup v-bind="group">
        <template #default="{ card, layout, focus, updateMetrics }">
          <LayeredLayoutCard
            :card-id="card.id"
            :style="layout.style"
            :is-focused="layout.isFocused"
            @focus="focus"
            @resize="updateMetrics"
          >
            <template #header>
              <div>{{ card.id }}</div>
            </template>
            <template #body>
              <div>Content for {{ card.id }}</div>
            </template>
          </LayeredLayoutCard>
        </template>
      </LayeredLayoutGroup>
    </template>
  </LayeredLayoutContainer>
</template>

<script setup>
import { ref } from 'vue';

const groups = ref([
  {
    id: 'main-group',
    cards: [
      { id: 'card1', minContentWidth: 400 },
      { id: 'card2', minContentWidth: 500, initialFocus: true },
      { id: 'card3', minContentWidth: 600 }
    ]
  }
]);
</script>
```

### 9.2 多卡片组

```vue
<template>
  <LayeredLayoutContainer :groups="groups">
    <template #default="{ group }">
      <LayeredLayoutGroup 
        v-bind="group"
        :class="group.className"
      >
        <!-- 卡片内容 -->
      </LayeredLayoutGroup>
    </template>
  </LayeredLayoutContainer>
</template>

<script setup>
const groups = ref([
  {
    id: 'top-group',
    className: 'top-panels',
    style: { borderBottom: '1px solid #ccc' },
    cards: [/* ... */]
  },
  {
    id: 'bottom-group',
    className: 'bottom-panels',
    breakpoint: 768,  // 独立的断点
    cards: [/* ... */]
  }
]);
</script>
```

## 10. 技术栈

- **Vue 3.4+**: Composition API
- **TypeScript 5.5+**: 类型安全
- **Vite 7**: 构建工具
- **Vitest 2**: 单元测试

## 11. 变更历史

### v0.2.0 (2025-10-01)

- ✨ 新增多卡片组支持
- ✨ 新增 `LayeredLayoutGroup` 组件
- 🔄 重构布局算法,移除多行打包
- 🔄 基于容器实际宽度判断布局方向
- ❌ 移除 `fixedContentWidth/Height`
- ✨ 支持自定义头部尺寸 `headerWidth/Height`
- ✨ `minContentWidth/Height` 默认值改为 500px
- ✨ 每个卡片组可独立设置 CSS 类名和样式

### v0.1.0

- 初始版本
